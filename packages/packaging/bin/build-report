#!/usr/bin/env node
const path = require('path');
const webpack = require('webpack');
const fs = require('fs');
const entry = path.resolve(process.cwd(), "client/index.js");
const examples = path.resolve(process.cwd(), "examples/");

function deleteFile(dir, file) {
  return new Promise(function (resolve, reject) {
      var filePath = path.join(dir, file);
      fs.lstat(filePath, function (err, stats) {
          if (err) {
              return reject(err);
          }
          if (stats.isDirectory()) {
              resolve(deleteDirectory(filePath));
          } else {
              fs.unlink(filePath, function (err) {
                  if (err) {
                      return reject(err);
                  }
                  resolve();
              });
          }
      });
  });
};

function deleteDirectory(dir) {
  return new Promise(function (resolve, reject) {
      fs.access(dir, function (err) {
          if (err) {
              return reject(err);
          }
          fs.readdir(dir, function (err, files) {
              if (err) {
                  return reject(err);
              }
              Promise.all(files.map(function (file) {
                  return deleteFile(dir, file);
              })).then(function () {
                  fs.rmdir(dir, function (err) {
                      if (err) {
                          return reject(err);
                      }
                      resolve();
                  });
              }).catch(reject);
          });
      });
  });
};

(async () => {
  try {
    await deleteDirectory("./dist");
    fs.mkdirSync("./dist");
  } catch(e) {
    // do nothing, already exists
    console.error(e);
  }
  
  
  const config = require("../webpack.config.js")(entry, examples)[0];
  
  const bundler = webpack(config);
  bundler.run((err, stats) => {
    if (err) {
      console.error(err.stack || err);
      if (err.details) {
        console.error(err.details);
      }
      return;
    }
  
    const info = stats.toJson();
  
    if (stats.hasErrors()) {
      for (var err of info.errors) {
        console.error(err);
      }
    }
  
    if (stats.hasWarnings()) {
      for (var msg of info.warnings) {
        console.warn(msg);
      }
    }
    // console.log(err, stats);
    fs.writeFileSync('./dist/profile.json', JSON.stringify(stats.toJson()));
  });
  
  
  require(`@babel/register`)({
    ignore: [/node_modules/],
    babelrc: false,
    plugins: ["@babel/plugin-proposal-class-properties"],
    presets: [
      "@babel/preset-react",
      ["@babel/preset-env", {
        useBuiltIns: "usage",
        targets: {
          node: 8
        }
      }]
    ]
  });
  // this won't be used, it's just so that the clients can be loaded for publish the module metadata
  process.env.CLIENT_VERSION = process.env.PACKAGING_VERSION = '0.0.0';
  const c = require(`${process.cwd()}/client/index.js`);
  const clients = [];
  for (var title of Object.keys(c)) {
    const client = c[title];
  
    clients.push({
      title: title,
      tabs: client.map((tab) => ({title: tab.title, sources: tab.sources}))
    });
  }
  
  fs.writeFileSync('./dist/modules.json', JSON.stringify(clients));  
})();
